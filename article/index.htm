<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Build a Simple Shape Drawing App</title>
</head>

<body>

<p>Build a Simple Shape Diagramming App with SVG and Javascript</p>
<h2>Introduction</h2>
<p>I've been wanting to learn about SVG for a while now, and there are certainly 
any number of helpful websites on creating SVG drawings and animations.&nbsp; 
But I didn't want to learn how to create static (or even animated) SVG drawings, 
I wanted to learn how to use SVG dynamically:</p>
<ul>
	<li>Create, modify, and remove SVG elements dynamically.</li>
	<li>Hook events for moving elements around, changing their attributes, etc.</li>
	<li>Save and restore a drawing.</li>
	<li>Discover quirks and how to work around them.</li>
</ul>
<p>That's what this article is about -- it will only teach you SVG and 
Javascript in so far as to achieve the goals outlined above.&nbsp; However, what 
it will teach you is how to create dynamic SVG drawings, and what better way to 
do this than to actually create a simple drawing program.&nbsp; Then again, I 
learned a lot about both SVG and modern Javascript writing this article.</p>
<h3>draw.io</h3>
<p>One of the best online SVG drawing programs is <a href="https://www.draw.io/">
draw.io</a> and I'm not going to attempt to recreate it.&nbsp; However, like 
many things, it is often useful to &quot;roll your own&quot; to understand how the 
technologies is used.&nbsp; The online program draw.io is a nice front end for
<a href="http://jgraph.github.io/mxgraph/">mxgraph</a>, which has excellent 
documentation at <a href="https://jgraph.github.io/mxgraph/docs/manual.html">
https://jgraph.github.io/mxgraph/docs/manual.html</a>.&nbsp; Also see their API 
specifications which supports PHP, .NET, Java, and Javascript.&nbsp; If you're 
looking for a polished drawing program, similar to Visio, look at draw.io.&nbsp; 
If you want to<i> learn</i> about how 
this stuff is done, that's what this article is for.<i>&nbsp; </i></p>
<h2>Step 1: Creating a Scrollable Grid</h2>
<p><img border="0" src="grid1.png" width="276" height="200"></p>
<p>The first thing I wanted to learn how to do was create a grid that scrolls.&nbsp; 
It was easy enough to find an example on the Internet which I used as a starting 
point:</p>
<pre>&lt;svg id=&quot;svg&quot; width=&quot;801&quot; height=&quot;481&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;defs&gt;
    &lt;pattern id=&quot;smallGrid&quot; width=&quot;8&quot; height=&quot;8&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
      &lt;path d=&quot;M 8 0 H 0 V 8&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;0.5&quot; /&gt;
    &lt;/pattern&gt;
    &lt;pattern id=&quot;grid&quot; width=&quot;80&quot; height=&quot;80&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
      &lt;rect width=&quot;80&quot; height=&quot;80&quot; fill=&quot;url(#smallGrid)&quot; /&gt;
      &lt;!-- draw from upper right to upper left, then down to lower left --&gt;
      &lt;!-- This creates the appearance of an 80x80 grid when stacked --&gt;
      &lt;path d=&quot;M 80 0 H 0 V 80&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;2&quot; /&gt;
    &lt;/pattern&gt;
  &lt;/defs&gt;

  &lt;!-- a trick from my old Commodore 64 days is to extend the scrolling region beyond the viewport 
  and use mod 80 to reset the position to simulate a virtual space. --&gt;
  &lt;rect transform=&quot;translate(0, 0)&quot; id=&quot;surface&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; fill=&quot;url(#grid)&quot; /&gt;
&lt;/svg&gt;</pre>
<p>As I mentioned, I'm not going to go into the details of SVG but I will point 
out the core features:</p>
<ul>
	<li>There are two grids -- an outer grid every 80 pixels and an inner grid 
	every 8 pixels.</li>
	<li>The &quot;grid&quot; is actually created by drawing only two lines: the top line 
	(from right to left) and the left edge, from upper left to bottom left.&nbsp; 
	That's what the &quot;M 80 0 H 0 V 80&quot; does -- it creates a path starting at (80, 
	0), draws a horizontal line to (0, 0) and then a vertical line to (0, 80).</li>
	<li>The initial transform is a placeholder -- &quot;translate(0, 0)&quot; doesn't 
	actually do anything.</li>
</ul>
<h3>Simulating a Virtual Surface</h3>
<p><img border="0" src="bufferzone.png" width="217" height="163"></p>
<p>Notice that the rectangle is drawn with an off-screen buffer zone of (-80, 
-80) and (width + 80*2, height + 80*2).&nbsp; This is an old trick from which I 
used to program scrolling games on the Commodore 64 -- you would render the 
viewing area to include an off-screen buffer zone so that scrolling could be 
done simply by performing a translate (or on the C64, changing the screen memory 
pointer.)&nbsp; When scrolling a repeating pattern, one &quot;translates&quot; the 
viewable area +/- 80 mod 80 (the width and height of the grid) and it appears to 
the user as if there is an infinite virtual surface.</p>
<h3>Scrolling the Grid - Mouse Events</h3>
<p>The user scrolls the grid with a &quot;drag&quot; operation:</p>
<ul>
	<li>Mouse down to start.</li>
<li>Move mouse, which scrolls the grid.</li>
<li>Mouse up when done.</li>
</ul>
<p>We'll keep track of the following variables:</p>
<pre>var mouseDown = false;
var mouseDownX = 0;
var mouseDownY = 0;
var gridX = 0;
var gridY = 0;</pre>
<h4>Wiring up the Mouse Events</h4>
<p>This is very simple (but we'll see later that it gets more complicated 
because for actual shapes that may be removed from the drawing, we will want to 
unhook the event handlers):</p>
<pre>function initializeSurface() {
  var svg = document.getElementById(&quot;svg&quot;);
  var surface = svg.getElementById(&quot;surface&quot;);
  surface.addEventListener(&quot;mousedown&quot;, onMouseDown, false);
  surface.addEventListener(&quot;mouseup&quot;, onMouseUp, false);
  surface.addEventListener(&quot;mousemove&quot;, onMouseMove, false);
  surface.addEventListener(&quot;mouseleave&quot;, onMouseLeave, false);
} 

initializeSurface();</pre>
<h4>Best Practice</h4>
<p>Technically, we could just get the surface element directly from the 
document:</p>
<pre>var svgSurface = document.getElementById(&quot;surface&quot;);</pre>
<p>but I suppose using the <code>svg</code> element helps to prevent the 
possibility that the HTML has an element of the same name, particularly since we 
don't know how the programmer might create additional HTML.</p>
<h4>The Event Handlers</h4>
<p>Here we handle the <code>mousedown</code>, <code>mouseup</code>, and <code>mousemove</code> events:</p>
<pre>const LEFT_MOUSE_BUTTON = 0;

function onMouseDown(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON) {
    evt.preventDefault();
    mouseDown = true;
    mouseDownX = evt.clientX;
    mouseDownY = evt.clientY;
  }
}

function onMouseUp(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON) {
    evt.preventDefault();
    mouseDown = false;
  }
}

function onMouseMove(evt) {
  if (mouseDown) {
    evt.preventDefault();
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - mouseDownX;
    var mouseDY = mouseY - mouseDownY;
    gridX += mouseDX;
    gridY += mouseDY;
    mouseDownX = mouseX;
    mouseDownY = mouseY;
    var svg = document.getElementById(&quot;svg&quot;);
    var surface = svg.getElementById(&quot;surface&quot;);
    var dx = gridX % 80;
    var dy = gridY % 80;
    surface.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
  }
}</pre>
<p>A few things to note:</p>
<ul>
	<li>Apparently, some browsers such as Firefox has default drag/drop handling 
	so we call <code>evt.preventDefault()</code> to, well, prevent the default handling of 
	the event.</li>
	<li>The variables <code>gridX</code> and <code>gridY</code> track the absolute offset grid.</li>
	<li>The grid is translated by this absolute offset modulus 80 so we don't 
	exceed the boundaries of the buffer zone.</li>
	<li>Apparently there used to be some confusing between the W3C standard 
	(left button == 0) and Microsoft's concept, (left button == 1) but that seems 
	to be very old information -- testing on Chrome and Edge, the left button 
	value (as well as right and middle values) are consistent across these two 
	browsers.</li>
</ul>
<h4>Handling Moving the Mouse off the Grid</h4>
<p>There is no concept of &quot;mouse capture,&quot; so when the user drags the surface 
and the mouse moves outside of the SVG element, events, such as <code>mouseup</code>, are no 
longer received.&nbsp; If the user stops dragging <i>outside of the SVG element</i> 
by releasing the mouse button, the code is still in the dragging state because
the <code>mouseup</code> event didn't fire.&nbsp; So instead, when the mouse 
cursor leaves the element, we simulate a <code>mouseup</code> event by handling the <code>mouseleave</code> 
event.</p>
<pre>surface.addEventListener(&quot;mouseleave&quot;, onMouseLeave, false);

// If the mouse moves out of the surface area, the mouse up event will not trigger,
// so we clear the mouseDown flag so that scrolling does not resume &quot;by itself&quot; 
// when the user moves the mouse back onto the surface, which would otherwise 
// require the user to click to clear the mouseDown flag.
function onMouseLeave(evt) {
  evt.preventDefault();
  mouseDown = false;
}</pre>
<h2>Step 2: Resizing the Grid - Our First Dynamic SVG</h2>
<p><img border="0" src="grid2.png" width="363" height="248"></p>
<p>Of course, all the code above is hard-coded for a grid of dimensions 80x80 
with inner grid spacing of 8x8.&nbsp; We would like this to actually be user 
configurable.&nbsp; To do this, it's useful to rename some ID's and add 
additional ID's to the pattern 
definitions:</p>
<pre>&lt;defs&gt;
  &lt;pattern id=&quot;smallGrid&quot; width=&quot;8&quot; height=&quot;8&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
    &lt;path id=&quot;smallGridPath&quot; d=&quot;M 8 0 H 0 V 8&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;0.5&quot; /&gt;
  &lt;/pattern&gt;
  &lt;pattern id=&quot;largeGrid&quot; width=&quot;80&quot; height=&quot;80&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
    &lt;rect id=&quot;largeGridRect&quot;width=&quot;80&quot; height=&quot;80&quot; fill=&quot;url(#smallGrid)&quot; /&gt;
    &lt;!-- draw from upper right to upper left, then down to lower left --&gt;
    &lt;!-- This creates the appearance of an 80x80 grid when stacked --&gt;
    &lt;path id=&quot;largeGridPath&quot; d=&quot;M 80 0 H 0 V 80&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;2&quot; /&gt;
  &lt;/pattern&gt;
&lt;/defs&gt;</pre>
<p>For reasons that will become clear in the next section, I've also added a 
group around the rectangle that represents the grid:</p>
<pre>&lt;g id=&quot;surface&quot; transform=&quot;translate(0, 0)&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; &gt;
  &lt;rect id=&quot;grid&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; fill=&quot;url(#largeGrid)&quot; /&gt;
&lt;/g&gt; </pre>
<p>We need to track the width and height setting of the larger rectangles 
for modulus operator:</p>
<pre>// The default:
var gridCellW = 80;
var gridCellH = 80;</pre>
<p>and is used in the mousemove handler:</p>
<pre>var dx = gridX % gridCellW;
var dy = gridY % gridCellH;</pre>
<p>Given this function which changes the grid spacing to the screenshot at the 
start of this section, large grid is 100x100, small grid is 20x20:</p>
<pre>resizeGrid(100, 100, 20, 20);</pre>
<p>Here's the implementation:</p>
<pre> // Programmatically change the grid spacing for the larger grid cells and smaller grid cells.
function resizeGrid(lw, lh, sw, sh) {
  gridCellW = lw;
  gridCellH = lh;
  var elLargeGridRect = document.getElementById(&quot;largeGridRect&quot;);
  var elLargeGridPath = document.getElementById(&quot;largeGridPath&quot;);
  var elLargeGrid = document.getElementById(&quot;largeGrid&quot;);

  var elSmallGridPath = document.getElementById(&quot;smallGridPath&quot;);
  var elSmallGrid = document.getElementById(&quot;smallGrid&quot;);

  var elSvg = document.getElementById(&quot;svg&quot;);
  var elSurface = document.getElementById(&quot;surface&quot;);
  var elGrid = document.getElementById(&quot;grid&quot;);

  elLargeGridRect.setAttribute(&quot;width&quot;, lw);
  elLargeGridRect.setAttribute(&quot;height&quot;, lh);

  elLargeGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + lw + &quot; 0 H 0 V &quot; + lh);
  elLargeGrid.setAttribute(&quot;width&quot;, lw);
  elLargeGrid.setAttribute(&quot;height&quot;, lh);

  elSmallGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + sw + &quot; 0 H 0 V &quot; + sh);
  elSmallGrid.setAttribute(&quot;width&quot;, sw);
  elSmallGrid.setAttribute(&quot;height&quot;, sh);

  elGrid.setAttribute(&quot;x&quot;, -lw);
  elGrid.setAttribute(&quot;y&quot;, -lh);

  var svgW = elSvg.getAttribute(&quot;width&quot;);
  var svgH = elSvg.getAttribute(&quot;height&quot;);

  elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
  elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);

  elSurface.setAttribute(&quot;x&quot;, -lw);
  elSurface.setAttribute(&quot;y&quot;, -lh);

  elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
  elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
}</pre>
<p>That's a lot of manipulation of the DOM elements.&nbsp; What we're doing is:</p>
<ul>
	<li>Resetting the width and height of the outer grid rectangle and the 
	pattern dimensions.</li>
	<li>Resetting the width and height of the inner grid pattern dimensions.</li>
	<li>Changing the path of the out and inner grids to reflect the new 
	dimensions.</li>
	<li>Resizing the buffer zone and surface dimensions.</li>
</ul>
<h2>Step 3: Adding Some Static Shapes</h2>
<p><img border="0" src="grid3.png" width="326" height="227"></p>
<p>Remember the group that I added around the grid rectangle?&nbsp; We'll now 
add another group that is used for shapes, and we'll put a couple static shapes 
in that group:</p>
<pre>&lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;
  &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFC0C0&quot; /&gt;
  &lt;circle cx=&quot;175&quot; cy=&quot;125&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0FFC0&quot; /&gt;
&lt;/g&gt;</pre>
<p>Now, with a simple addition to the <code>mousemove</code> event, we can translate all the 
elements in the &quot;objects&quot; group as well so that they move as the surface is 
scrolled:</p>
<pre>function onMouseMove(evt) {
  if (mouseDown) {
    evt.preventDefault();
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - mouseDownX;
    var mouseDY = mouseY - mouseDownY;
    gridX += mouseDX;
    gridY += mouseDY;
    mouseDownX = mouseX;
    mouseDownY = mouseY;
    var surface = document.getElementById(&quot;surface&quot;);

    var dx = gridX % gridCellW;
    var dy = gridY % gridCellH;
    surface.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);

    var objects = document.getElementById(&quot;objects&quot;);
    objects.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + gridX + &quot;,&quot; + gridY + &quot;)&quot;);
  }
}</pre>
<p>The reason we use two separate groups is:</p>
<ul>
	<li>The surface is always translated modulus the large grid size</li>
<li>The objects <i>on the surface</i> must be translated by the absolute scroll 
offset.</li>
</ul>
<p>If we don't keep the two regions separate, we get the strange effect that the 
shapes return to their original positions as a result of the modulus operation.&nbsp; 
Obviously we don't want that.</p>
<h2>Step 4:&nbsp; Moving Shapes Around</h2>
<p>At this point, we have to start getting more sophisticated about how mouse 
events are captured -- each shape (including the surface) must handle its own 
mouse events.&nbsp; However, what the event does is not always the same -- for 
example, scrolling the surface grid is different than moving a shape in the 
&quot;objects&quot; group.&nbsp; Later on, even more complicated mouse move activities 
will require tracking the state of the operation -- are we moving the shape, 
resizing it, rotating it, etc.?</p>
<p>It's a big leap, but it really is of benefit to create an actual 
<code>MouseController</code> class and to create a class model for the specialized behaviors of the 
different shapes.&nbsp; If we do this now, it becomes a lot easier to continue 
expanding the capabilities of what so far has just been a playground to test 
things out.</p>
<h3>The Mouse Controller</h3>
<p>The <code>MouseController</code> class does a few things for us:</p>
<ul>
	<li>It tracks the shape being dragged.&nbsp; This is important because the 
	user can move the mouse in a larger increment than the size of the shape.&nbsp; 
	When this happens, the mouse &quot;escapes&quot; the shape and it no longer receives 
	<code>mousemove</code> events.&nbsp; So once a shape (including the surface 
	grid) is &quot;captured&quot; by <code>mousedown</code> event, the <code>mousemove</code> events are passed 
	along to the controller responsible for that shape.</li>
	<li>It maps shape ID's to shape controllers.&nbsp; This allows the mouse 
	controller to route mouse events to the controller associated with the 
	shape.</li>
	<li>It implements some basic behavioral features such as where the user 
	clicked and the basic logic of mouse down -&gt; drag -&gt; mouse up operations.&nbsp; 
	Later on additional states can be added besides dragging -- states such as 
	resizing.</li>
</ul>
<p>The implementation is rather basic right now, building on what we did before:</p>
<pre>const LEFT_MOUSE_BUTTON = 0;

class MouseController {
  constructor() {
    this.mouseDown = false;
    this.controllers = {};
    this.activeController = null;
  }

  // Create a map between then SVG element (by it's ID, so ID's must be unique) and its controller.
  attach(svgElement, controller) {
    var id = svgElement.getAttribute(&quot;id&quot;);
    this.controllers[id] = controller;
  }

  detach(svgElement) {
    var id = svgElement.getAttribute(&quot;id&quot;);
    delete this.controllers[id];
  }

  // Get the controller associated with the event and remember where the user clicked.
  onMouseDown(evt) {
    if (evt.button == LEFT_MOUSE_BUTTON) {
      evt.preventDefault();
      var id = evt.currentTarget.getAttribute(&quot;id&quot;);
      this.activeController = this.controllers[id];
      this.mouseDown = true;
      this.mouseDownX = evt.clientX;
      this.mouseDownY = evt.clientY;
    }
  }

  // If the user is dragging, call the controller's onDrag function.
  onMouseMove(evt) {
    evt.preventDefault();

    if (this.mouseDown &amp;&amp; this.activeController != null) {
      this.activeController.onDrag(evt);
    }
  }

  // Any dragging is now done.
  onMouseUp(evt) {
    if (evt.button == LEFT_MOUSE_BUTTON) {
      evt.preventDefault();
      this.clearSelectedObject();
    }
  }

  // Any dragging is now done.
  onMouseLeave(evt) {
    evt.preventDefault();
    if (this.mouseDown &amp;&amp; this.activeController != null) {
      this.activeController.onMouseLeave();
    }
  }

  clearSelectedObject() {
    this.mouseDown = false;
    this.activeController = null;
  }
}</pre>
<h3>The Shape Object Model</h3>
<p><img border="0" src="svgmodel.png" width="539" height="226"></p>
<p>The diagram above illustrates the shape object model I've put together.</p>
<h4>The SvgObject Class</h4>
<p>This is the root class which keeps track of:</p>
<ul>
	<li>The mouse controller (a shared object between all shapes).</li>
<li>The shape's translation (it's offset from origin).&nbsp; I've seen various 
techniques for this by using attributes directly in the elements tag rather than 
parsing the <code>transform=&quot;translate(x, y)&quot;</code> string in order to update the 
translation, but I'd rather keep this as variables in the shape's class 
instance.</li>
	<li>An event registration method so that when the shape is removed, all its 
	associated event handlers can be unhooked.</li>
	<li>Default implementations for the basic drag operation math and other 
	events.</li>
	<li>Binding the event handler to &quot;this&quot; as the default class instance or to 
	a specified class instance (usually the mouse controller.)</li>
</ul>
<pre>class SvgObject {
  constructor(mouseController, svgElement) {
    this.mouseController = mouseController;
    this.events = [];
    this.X = 0;
    this.Y = 0;
    this.mouseController.attach(svgElement, this);
  }

  // Register the event so that when we destroy the object, we can unwire the event listeners.
  registerEvent(element, eventName, callbackRef) {
    this.events.push({ element: element, eventName: eventName, callbackRef: callbackRef });
  }

  destroy() {
    this.unhookEvents();
  }

  registerEventListener(element, eventName, callback, self) {
    var ref;

    if (self == null) {
      self = this;
    }

    element.addEventListener(eventName, ref = callback.bind(self));
    this.registerEvent(element, eventName, ref);
  }

  unhookEvents() {
    for (var i = 0; i &lt; this.events.length; i++) {
      var event = this.events[i];
      event.element.removeEventListener(event.eventName, event.callbackRef);
    }

    this.events = [];
  }

  updatePosition(evt) {
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - this.mouseController.mouseDownX;
    var mouseDY = mouseY - this.mouseController.mouseDownY;
    this.X += mouseDX;
    this.Y += mouseDY;
    this.mouseController.mouseDownX = mouseX;
    this.mouseController.mouseDownY = mouseY;
  }

  onMouseLeave(evt) { }
}</pre>
<h4>The SvgElement Class</h4>
<p>This class extends the <code>SvgObject</code> class, providing default mouse event 
registration and shape drag implementation:</p>
<pre>class SvgElement extends SvgObject {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
    this.element = svgElement;
    this.registerEventListener(this.element, &quot;mousedown&quot;, mouseController.onMouseDown, mouseController);
    this.registerEventListener(this.element, &quot;mouseup&quot;, mouseController.onMouseUp, mouseController);
    this.registerEventListener(this.element, &quot;mousemove&quot;, mouseController.onMouseMove, mouseController);
  }

  onDrag(evt) {
    this.updatePosition(evt);
    this.element.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
  }
}</pre>
<p>Most of the time the &quot;this&quot; that is used to bind the event callback to the 
handling class instance will be the mouse controller, but the functionality has 
been provided to use the class instance registering the event (this is the 
default behavior) or some other class instance to which we want to bind the 
handler.</p>
<h4>The Circle Class</h4>
<p>The <code>Circle</code> class demonstrates the most basic of elements in which all the 
default behaviors can be utilized.&nbsp; It merely extends the <code>SvgElement</code> class.</p>
<pre>class Circle extends SvgElement {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
  }
}</pre>
<h4>The Surface Class</h4>
<p>This class is much more complicated as it has to handle all the things we 
talked about before regarding scrolling the grid and objects on the grid.&nbsp; 
Note how it extends the <code>mouseleave</code> event.&nbsp; We want this to 
pass through the mouse controller's test to ensure that a drag operation is 
occurring when the mouse &quot;leaves&quot; the shape.&nbsp; Depending on the selected 
shape (the active controller) the behavior is different:</p>
<ul>
	<li>in case of leaving the surface, the surface class is implemented such 
	that the drag operation is cleared.</li>
<li>In the case of leaving a shape, nothing happens as we want the shape to 
catch up to mouse position.</li>
</ul>
<pre>class Surface extends SvgElement {
  constructor(mouseController, svgSurface, svgObjects) {
    super(mouseController, svgSurface);
    this.svgObjects = svgObjects;
    this.gridCellW = 80;
    this.gridCellH = 80;

    this.registerEventListener(this.svgSurface, &quot;mouseleave&quot;, mouseController.onMouseLeave, mouseController);
  }

  onDrag(evt) {
    this.updatePosition();
    var dx = this.X % this.gridCellW;
    var dy = this.Y % this.gridCellH;
    this.scrollSurface(dx, dy, this.X, this.Y);
  }

  onMouseLeave() {
    this.mouseController.clearSelectedObject();
  }

  scrollSurface(dx, dy, x, y) {
    // svgElement is the surface.
    this.svgElement.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
    this.svgObjects.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + x + &quot;,&quot; + y + &quot;)&quot;);
  }

 function resizeGrid(lw, lh, sw, sh) {
    this.gridCellW = lw;
    this.gridCellH = lh;
    var elLargeGridRect = document.getElementById(&quot;largeGridRect&quot;);
    var elLargeGridPath = document.getElementById(&quot;largeGridPath&quot;);
    var elLargeGrid = document.getElementById(&quot;largeGrid&quot;);

    var elSmallGridPath = document.getElementById(&quot;smallGridPath&quot;);
    var elSmallGrid = document.getElementById(&quot;smallGrid&quot;);

    var elSvg = document.getElementById(&quot;svg&quot;);
    var elSurface = document.getElementById(&quot;surface&quot;);
    var elGrid = document.getElementById(&quot;grid&quot;);

    elLargeGridRect.setAttribute(&quot;width&quot;, lw);
    elLargeGridRect.setAttribute(&quot;height&quot;, lh);

    elLargeGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + lw + &quot; 0 H 0 V &quot; + lh);
    elLargeGrid.setAttribute(&quot;width&quot;, lw);
    elLargeGrid.setAttribute(&quot;height&quot;, lh);

    elSmallGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + sw + &quot; 0 H 0 V &quot; + sh);
    elSmallGrid.setAttribute(&quot;width&quot;, sw);
    elSmallGrid.setAttribute(&quot;height&quot;, sh);

    elGrid.setAttribute(&quot;x&quot;, -lw);
    elGrid.setAttribute(&quot;y&quot;, -lh);

    var svgW = elSvg.getAttribute(&quot;width&quot;);
    var svgH = elSvg.getAttribute(&quot;height&quot;);

    elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
    elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
    
    elSurface.setAttribute(&quot;x&quot;, -lw);
    elSurface.setAttribute(&quot;y&quot;, -lh);

    elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
    elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
  }
}</pre>
<h3>Wrapping Up Moving Shapes</h3>
<p><img border="0" src="grid4.png" width="263" height="195"></p>
<p>To get this all to work, we need to add ID's to the two static circles in the 
&quot;objects&quot; group:</p>
<pre>&lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;
  &lt;circle id=&quot;circle1&quot; cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFC0C0&quot; /&gt;
  &lt;circle id=&quot;circle2&quot; cx=&quot;175&quot; cy=&quot;125&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0FFC0&quot; /&gt;
&lt;/g&gt;</pre>
<p>We then create the class instances and in the constructor pass in the mouse 
controller instance and shape element:</p>
<pre>(function initialize() {
  var mouseController = new MouseController();
  var svgSurface = document.getElementById(&quot;surface&quot;);
  var svgObjects = document.getElementById(&quot;objects&quot;);
  var svgCircle1 = document.getElementById(&quot;circle1&quot;);
  var svgCircle2 = document.getElementById(&quot;circle2&quot;);
  var surface = new Surface(mouseController, svgSurface, svgObjects);
  surface.resizeGrid(100, 100, 20, 20);
  new Circle(mouseController, svgCircle1);
  new Circle(mouseController, svgCircle2);
})();</pre>
<p>That's it!&nbsp; But where are we actually dragging the shapes?&nbsp; This 
may have escaped the casual reader--it is happening in the SvgElement class!</p>
<pre>onDrag(evt) {
  this.updatePosition(evt);
  this.element.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
}</pre>
<p>Any shape that derives from <code>SvgElement</code> inherits the ability to be dragged 
around the surface.&nbsp; For example, we'll add a rectangle:</p>
<pre>&lt;rect id=&quot;nose&quot; x=&quot;200&quot; y=&quot;150&quot; width=&quot;40&quot; height=&quot;60&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0C0FF&quot; /&gt;</pre>
<p>Define the class <code>Rectangle</code>, which doesn't override anything yet, just like <code>Circle</code>:</p>
<pre>class Rectangle extends SvgElement {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
  }
}</pre>
<p>and instantiate the shape with the associated SVG element:</p>
<pre>new Rectangle(mouseController, document.getElementById(&quot;nose&quot;));</pre>
<p>and we get (after moving the shapes around):</p>
<p><img border="0" src="grid5.png" width="256" height="209"></p>
<h2>Step 5: A Toolbox and Dynamic Shape Creation</h2>
<p>Let's make what we're doing more useful by adding a toolbox so we can drag 
and drop new shapes on the surface.&nbsp; The toolbox will be the third group, 
making it the topmost group so that everything else (grid and objects) are 
always rendered <i>behind</i> the toolbox:</p>
<pre>&lt;g id=&quot;toolboxGroup&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot;&gt;
  &lt;rect id=&quot;toolbox&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;0.5&quot; /&gt;
&lt;/g&gt;</pre>
<h2>Step 5: A Toolbox and Dynamic Shape Creation</h2>
<p>Let's make what we're doing more useful by adding a toolbox so we can drag 
and drop new shapes on the surface.&nbsp; The toolbox will be the third group, 
making it the topmost group so that everything else (grid and objects) are 
always rendered <i>behind</i> the toolbox:</p>
<pre>&lt;g id=&quot;toolboxGroup&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot;&gt;
  &lt;rect id=&quot;toolbox&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;0.5&quot; /&gt;
  &lt;rect id=&quot;toolboxRectangle&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;40&quot; height=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;circle id=&quot;toolboxCircle&quot; cx=&quot;85&quot; cy=&quot;29&quot; r=&quot;21&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;path id=&quot;toolboxDiamond&quot; d=&quot;M 140 10 L 115 30 L 140 50 L 165 30 Z&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
&lt;/g&gt;</pre>
<p><img border="0" src="toolbox1.png" width="446" height="217"></p>
<h3>Supporting Classes</h3>
<p>We're going to need a some additional classes (indicated with the red text):</p>
<p><img border="0" src="toolbox2.png" width="709" height="331"></p>
<h3>Initialization</h3>
<p>Here's the entire initialization code (I've removed the static shapes we had 
previously):</p>
<pre>const SVG_ELEMENT_ID = &quot;svg&quot;;
const SVG_SURFACE_ID = &quot;surface&quot;;
const SVG_TOOLBOX_SURFACE_ID = &quot;toolboxSurface&quot;;
const SVG_OBJECTS_ID = &quot;objects&quot;;

(function initialize() {
  var mouseController = new MouseController();
  var svgSurface = getElement(SVG_SURFACE_ID);
  var svgToolboxSurface = getElementBy(SVG_TOOLBOX_SURFACE_ID);
  var svgObjects = getElement(SVG_OBJECTS_ID);

  var surface = new Surface(mouseController, svgSurface, svgObjects);
  surface.resizeGrid(100, 100, 20, 20);

  var toolboxController = new ToolboxController(mouseController);

  // So we can handle mouse drag operations when the mouse moves onto the toolbox surface...
  var toolboxSurface = new ToolboxSurface(toolboxController, svgToolboxSurface);

  // The surface mouse controller needs to know the toolbox controller to finish
  // a toolbox drag &amp; drop operation.
  mouseController.setToolboxController(toolboxController);
  // To compensate for translations when doing a toolbox drag&amp;drop
  mouseController.setSurfaceShape(surface);
  toolboxController.setSurfaceShape(surface);

  new ToolboxRectangle(toolboxController, getElement(&quot;toolboxRectangle&quot;));
  new ToolboxCircle(toolboxController, getElement(&quot;toolboxCircle&quot;));
  new ToolboxDiamond(toolboxController, getElement(&quot;toolboxDiamond&quot;));
})();</pre>
<p>Notice some changes (will be explained next):</p>
<ul>
	<li>There are setter methods to tell the mouse controller (which handles the 
	surface) about the toolbox controller and surface &quot;shape.&quot;&nbsp; This will 
	be explained shortly.</li>
	<li>The toolbox controller is derived from the mouse controller, as it is a 
	specialized mouse controller for handling drag &amp; drop as well as &quot;click and 
	drop&quot; operations.</li>
	<li>The toolbox controller needs to know about the surface &quot;shape.&quot;</li>
	<li>Lastly, we initialize the objects backing the toolbox shapes.</li>
</ul>
<p>I also added a simple helper method that, granted, I'm not using everywhere, 
but is less typing:</p>
<pre>function getElement(id) {
  var svg = document.getElementById(SVG_ELEMENT_ID);
  var el = svg.getElementById(id);

  return el;
}</pre>
<p>Also, the better practice here is that the we're looking for element ID's in 
the &quot;svg&quot; element, not the document.</p>
<h3>The Toolbox Shapes</h3>
<p>The toolbox shapes all implement the following functions:</p>
<ul>
	<li>createElement - this creates an element with a starting location to 
	place it on the surface next to the toolbox.&nbsp; This is used for &quot;click 
	and drop&quot; operations.</li>
	<li>createElementAt - this creates an element at the specified location.&nbsp; 
	This is used for &quot;drag and drop&quot; operations.</li>
	<li>createShape - instantiates the associated non-toolbox shape.</li>
</ul>
<p>So, for example (choosing the diamond because it's a bit more complex):</p>
<pre>class ToolboxDiamond extends SvgToolboxElement {
  constructor(toolboxController, svgElement) {
    super(toolboxController, svgElement);
  }

  // For click and drop
  createElement() {
    var el = super.createElement('path', 
      { d: &quot;M 240 100 L 210 130 L 240 160 L 270 130 Z&quot;, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1, fill: &quot;#FFFFFF&quot; });

    return el;
  }

  // For drag and drop
  createElementAt(x, y) {
    var points = [
      { cmd: &quot;M&quot;, x: x-15, y: y-30 }, 
      { cmd: &quot;L&quot;, x: x - 45, y: y }, 
      { cmd: &quot;L&quot;, x: x-15, y: y + 30 }, 
      { cmd: &quot;L&quot;, x: x + 15, y: y }];

    var path = points.reduce((acc, val) =&gt; acc = acc + val.cmd + &quot; &quot; + val.x + &quot; &quot; + val.y, &quot;&quot;);
    path = path + &quot; Z&quot;;
    var el = super.createElement('path', { d: path, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1, fill: &quot;#FFFFFF&quot; });

    return el;
  }

  createShape(mouseController, el) {
    var shape = new Diamond(mouseController, el);

    return shape;
  }
}</pre>
<p>All the toolbox shapes follow the above template.</p>
<h3>The SvgToolboxElement Class</h3>
<p>The base class for all toolbox elements wires up the mouse events for toolbox 
shape elements to the <i>toolboxController</i>.&nbsp; It also provides a common 
method for creating an element and setting its attributes, including creating a 
unique ID for the element:</p>
<pre>class SvgToolboxElement extends SvgObject {
  constructor(toolboxController, svgElement) {
    super(toolboxController, svgElement);
    this.toolboxController = toolboxController;
    this.registerEventListener(svgElement, &quot;mousedown&quot;, toolboxController.onMouseDown, toolboxController);
    this.registerEventListener(svgElement, &quot;mouseup&quot;, toolboxController.onMouseUp, toolboxController);
    this.registerEventListener(svgElement, &quot;mousemove&quot;, toolboxController.onMouseMove, toolboxController);
    this.svgns = &quot;<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>&quot;;
  }

  // Create the specified element with the attributes provided in a key-value dictionary.
  createElement(elementName, attributes) {
    var el = document.createElementNS(this.svgns, elementName);

    // Create a unique ID for the element so we can acquire the correct shape controller
    // when the user drags the shape.
    el.setAttributeNS(null, &quot;id&quot;, this.uuidv4());

    // Create a class common to all shapes so that, on file load, we can get them all and re-attach them
    // to the mouse controller.
    el.setAttributeNS(null, &quot;class&quot;, SHAPE_CLASS_NAME);

    // Add the attributes to the element.
    Object.entries(attributes).map(([key, val]) =&gt; el.setAttributeNS(null, key, val));

    return el;
  }

  // From SO: <a href="https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript">https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript</a>
  uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; 
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16))
  }
}</pre>
<h3>The ToolboxController Class</h3>
<p>Most of how the &quot;click and drop&quot; and &quot;drag and drop&quot; behavior is handled 
here.&nbsp; Remember that this class derives from MouseController, however it 
also needs to be initialized with the <i>surface</i> mouse controller -- it gets 
interesting (or perhaps confusing) to have two mouse controllers in this class!</p>
<h4>Constructor</h4>
<pre>class ToolboxController extends MouseController {
  // We pass in the mouse controller that the surface is using so we can 
  // pass control over to the surface mouse controller when dragging a shape.
  constructor(mouseController) {
    super();
    this.mouseController = mouseController;
    this.draggingShape = false;
  }</pre>
<p>As the comments state, we need the <i>surface</i> mouse controller so that 
for drag &amp; drop operations, we can pass off the shape dragging to the <i>surface</i> 
mouse controller.&nbsp; When dragging, a non-toolbox shape is created.&nbsp; 
This shape wires up the mouse events using the <i>surface</i> mouse controller, 
which is why we need to pass control over to that controller.&nbsp; The 
alternative would be to tell the shape how to route the mouse events, and once 
the shape is dropped onto the surface, the events would have to be detached from 
the toolbox controller and attached to the surface mouse controller.&nbsp; So it 
merely shoves the problem around.&nbsp; Still, there might be a better way to do 
this.</p>
<h4>Toolbox Controller onMouseDown</h4>
<pre>onMouseDown(evt) {
  super.onMouseDown(evt);
}</pre>
<p>We let the base class handle this behavior.&nbsp; The event is wired up to 
the toolbox controller.</p>
<h4>Determining a Click Event</h4>
<pre>isClick(evt) {
  var endDownX = evt.clientX;
  var endDownY = evt.clientY;

  var isClick = Math.abs(this.startDownX - endDownX) &lt; TOOLBOX_DRAG_MIN_MOVE &amp;&amp;
                Math.abs(this.startDownY - endDownY) &lt; TOOLBOX_DRAG_MIN_MOVE;

  return isClick;
}</pre>
<p>While we could use the &quot;onclick&quot; event, I want finer grained control and I 
don't want to deal with whether the click event fires after a mouse up &quot;click 
and drag&quot; vs. a mouse up &quot;drag and drop.&quot;&nbsp; OK, I still have to worry about 
that, but it makes more sense (to me at least) to just handle this in the mouse 
up event.</p>
<h4>Toolbox Controller onMouseUp</h4>
<pre>// If this is a &quot;click&quot;, create the shape in a fixed location on the surface.
// If this is the end of a drag operation, place the shape on the surface at
// the current mouse position.
onMouseUp(evt) {
  if (this.isClick(evt)) {
    // Treat this as a click.
    var el = this.activeController.createElement();

    // The new shape is attached to the grid surface's mouse controller.
    var shape = this.activeController.createShape(this.mouseController, el);

    // Account for surface translation (scrolling)
    shape.translate(-this.surfaceShape.X, -this.surfaceShape.Y);

    // Use the mouse controller associated with the surface.
    this.dropShapeOnSurface(SVG_OBJECTS_ID, el, shape);
    this.mouseDown = false;
  }
}</pre>
<p>This is the heart of the &quot;click &amp; drag&quot; behavior.&nbsp; A click is determined 
by a mouse up event occurring within a motion &quot;window.&quot;&nbsp; After that:</p>
<ul>
	<li>The &quot;real&quot; shape is created.</li>
	<li>Translated to account for surface translation.</li>
	<li>Dropped onto the surface.</li>
	<li>Cleanup.</li>
</ul>
<p>Dropping the shape onto the surface involves appending the shape to the 
&quot;objects&quot; group and telling the surface mouse controller about the shape:</p>
<pre>dropShapeOnSurface(groupName, svgElement, shapeController) {
  getElement(groupName).appendChild(svgElement);
  this.mouseController.attach(svgElement, shapeController);
}</pre>
<h4>Toolbox Controller onMouseMove</h4>
<pre>// If the user is dragging, we create a new shape that can be dragged onto
// the surface. When the drag operation ends, the shape is transferred to the surface.
onMouseMove(evt) {
  if (this.mouseDown) {
    evt.preventDefault();
    if (this.draggingShape) {
      // Our toolbox surface picked up the event instead of the shape. Handle
      // as if the shape got the event.
      super.onMouseMove(evt);
    } else {
      // Make sure a shape has been selected rather than dragging the toolbox surface.
      if (!(this.activeController instanceof ToolboxSurface)) {
        if (!this.isClick(evt)) {
          var endDownX = evt.clientX;
          var endDownY = evt.clientY;
          var el = this.activeController.createElementAt(endDownX, endDownY);
          // Here, because we're dragging, the shape needs to be attached to both the toolbox controller and the surface's mouse controller
          // so that if the user moves the shape too quickly, either the toolbox controller or the surface controller will pick it up.
          var shape = this.activeController.createShape(this.mouseController, el);
          // set the shape name so we can map shape names to shape constructors when loading a diagram.
          el.setAttributeNS(null, &quot;shapeName&quot;, shape.constructor.name);
          shape.mouseController.mouseDownX = endDownX;
          shape.mouseController.mouseDownY = endDownY + 30; // Offset so shape is drawn under mouse.
          this.createShapeForDragging(el, shape);
          this.draggingShape = true;
        }
      }
    }
  }
}</pre>
<p>This is the most complicated piece.&nbsp; The above code handles:</p>
<ul>
	<li>If the user moves the shape quickly, the toolbox surface might get the 
	event, so we handle the default behavior which is to update the shape's 
	translation.&nbsp; 
	<ul>
		<li>One caveat -- if the mouse is moving within the click window, the 
		surface mouse controller doesn't have the active shape yet, so nothing 
		happens.</li>
	</ul>
	</li>
	<li>We also don't want the user dragging the toolbox surface itself.&nbsp; 
	At least not yet.&nbsp; Maybe this will scroll the shapes in the toolbox 
	later.</li>
	<li>A drag operation begins only when the user has moved the mouse enough to 
	not be considered a click event.</li>
	<li>The shape is handed off to the <i>surface</i> mouse controller at this 
	point.</li>
</ul>
<p>When the shape is created for dragging, it is actually appended to the <i>
toolbox</i> SVG group, so it stay in the foreground while the user moves the 
shape over to the grid.&nbsp; Later we have to move the shape to the <i>object</i>s<i> 
SVG </i>group<i>.</i></p>
<pre>// Place the shape into the toolbox group so it's topmost, and attach the shape to mouse our toolbox mouse controller
// and the surface mouse controller so off-shape mouse events are handled correctly.
createShapeForDragging(el, shape) {
  // The shape is now under the control of the surface mouse controller even though we added it to our toolbox group.
  // This is because the shape wires up the surface mouse controller events.
  // The only thing the toolbox controller will see is the onMouseMove when the user moves the mouse too fast and the
  // mouse events end up being handled by the toolbox controller (or, if over the surface, the surface controller.)
  this.dropShapeOnSurface(SVG_TOOLBOX_ID, el, shape);

  // We need to know what shape is being moved, in case we (the tookbox controller) start to receive mouse move events.
  this.attach(el, shape);
  this.activeController = shape;

  // The surface mouse controller also needs to know what shape is active and that we are in the &quot;mouse down&quot; state.
  this.mouseController.activeController = shape;
  this.mouseController.mouseDown = true;
}</pre>
<p>At this point, the surface mouse controller has control!</p>
<h4>Mouse Controller onMouseUp</h4>
<pre>// Any dragging is now done.
onMouseUp(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON &amp;&amp; this.activeController != null) {
    evt.preventDefault();
    // Allows the toolbox controller to finish the drag &amp; drop operation.
    this.toolboxController.mouseUp();
    this.clearSelectedObject();
  }
}</pre>
<p>As stated above, the <i>surface</i> mouse controller has control of the shape 
when the drag operation begins.&nbsp; When <i>it</i> receives a mouse up event, 
it gives the toolbox controller the opportunity to finish any toolbox drag &amp; 
drop operation:</p>
<pre>// Handles end of drag &amp; drop operation, otherwise, does nothing -- toolbox item was clicked.
mouseUp() {
  if (this.draggingShape) {
    // Account for surface translation (scrolling)
    this.activeController.translate(-this.surfaceShape.X, -this.surfaceShape.Y);

    var el = this.activeController.svgElement;

    // Move element out of the toolbox group and into the objects group.
    getElement(SVG_TOOLBOX_ID).removeChild(el);
    getElement(SVG_OBJECTS_ID).appendChild(el);
    this.dragComplete(el);
  }
}</pre>
<p>Here the element is moved from the topmost foreground position (in the 
toolbox SVG group) to the objects SVG group.&nbsp; We also have to account for 
any surface translation so the shape is appears exactly where it is when the 
user concludes the drag operation.&nbsp; Lastly, we clean up the toolbox 
controller's state:</p>
<pre>dragComplete(el) {
  this.draggingShape = false;
  this.detach(el);
  this.mouseDown = false;
  this.activeController = null;
}</pre>
<pre><img border="0" src="toolbox3.png" width="532" height="363"></pre>
<p>Phew!&nbsp; All done!&nbsp; (Except maybe getting the shapes to click &amp; drop 
at more uniform location.)</p>
<h2>Step 6: Saving and Restoring the Diagram Locally</h2>
<p>We have enough happening now that before doing anything else, I think it's a 
good idea to look at how shapes are saved and loaded locally.&nbsp; The 
implementation I present here is very rudimentary -- it automatically initiates 
a download which will go into the Downloads folder, and in Chrome, any existing 
file causes the filename to be appended with (n) where n is an incrementing 
number.&nbsp; At some point I will enhance this functionality using the HTML5 
FileSystem API (<a href="https://www.html5rocks.com/en/tutorials/file/filesystem/">https://www.html5rocks.com/en/tutorials/file/filesystem/</a> 
and <a href="https://dev.w3.org/2009/dap/file-system/pub/FileSystem/">
https://dev.w3.org/2009/dap/file-system/pub/FileSystem/</a>), part of the
<a href="https://developer.mozilla.org/en-US/docs/WebAPI">WebAPI</a>.&nbsp; But for now, it 
writes &quot;data.svg&quot; and on load, let's you select the directory and file.&nbsp; 
Rather than focusing on the UI for saving/loading diagrams, the point here is to 
focus on the mechanics of actually saving and loading the diagram itself.&nbsp; 
Between figuring out how to write the Javascript, working with the SVG DOM, and 
fixing bugs, this took two days!</p>
<p><img border="0" src="saveload1.png" width="422" height="182"></p>
<p>To begin with, I added Save and Load buttons at the top of the page:</p>
<pre>&lt;div&gt;
  &lt;!-- <a href="https://stackoverflow.com/questions/1944267/how-to-change-the-button-text-of-input-type-file%20--">https://stackoverflow.com/questions/1944267/how-to-change-the-button-text-of-input-type-file --</a>&gt;
  &lt;!-- creates a hidden file input on routes the button to clicking on that tag --&gt;
  &lt;button onclick=&quot;saveSvg()&quot;&gt;Save&lt;/button&gt;
  &lt;button onclick=&quot;document.getElementById('fileInput').click();&quot;&gt;Load&lt;/button&gt;
  &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; style=&quot;display:none;&quot;/&gt;
&lt;/div&gt;</pre>
<p>The trick here, to avoid the default behavior of a file input element, was to 
hide the input element, as to SO link showed me.</p>
<h3>Saving the Diagram</h3>
<p>Saving the SVG <i>locally</i> took some research and resulted n this code:</p>
<pre>document.getElementById(FILE_INPUT).addEventListener('change', readSingleFile, false);</pre>
<pre>// https://stackoverflow.com/questions/23582101/generating-viewing-and-saving-svg-client-side-in-browser
function saveSvg() {
  var svg = getElement(SVG_OBJECTS_ID);
  // <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer">https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer</a>
  var serializer = new XMLSerializer();
  var xml = serializer.serializeToString(svg);
  // Prepend the xml with other things we want to save, like the surface translation and grid spacing.
  xml = &quot;&lt;diagram&gt;&quot; + surface.serialize() + &quot;&lt;/diagram&gt;&quot; + xml;
  var blob = new Blob([xml], { 'type': &quot;image/svg+xml&quot; });

  // We're using <a href="https://github.com/eligrey/FileSaver.js/">https://github.com/eligrey/FileSaver.js/</a>
  // but with the &quot;export&quot; (a require node.js thing) removed.
  // There are several forks of this, not sure if there's any improvements in the forks.
  saveAs(blob, FILENAME);
}</pre>
<p>As the comments point out, I'm using FileSaver.js, written by &quot;eligrey.&quot;&nbsp; 
Thank goodness for open source -- this works in Chrome and Edge (the two 
browsers I tested) and has support for other browser's nuances as well.&nbsp; Of 
particular note here:</p>
<ul>
	<li>We're giving the surface (and maybe other objects later on) the 
	opportunity to save their state.&nbsp; The surface needs to save:<ul>
		<li>It's translation.</li>
		<li>The grid spacing.</li>
	</ul>
</li>
	<li>This data, as an XML string, is prepended to the SVG data.</li>
</ul>
<p>In the surface class, this is implemented as:</p>
<pre>// Create an XML fragment for things we want to save here.
serialize() {
  var el = document.createElement(&quot;surface&quot;);
  // DOM adds elements as lowercase, so let's just start with lowercase keys.
  var attributes = {x : this.X, y : this.Y, gridcellw : this.gridCellW, gridcellh : this.gridCellH, 
                    cellw : this.cellW, cellh : this.cellH}
  Object.entries(attributes).map(([key, val]) =&gt; el.setAttribute(key, val));
  var serializer = new XMLSerializer();
  var xml = serializer.serializeToString(el);

  return xml;
}</pre>
<p>That was the easy part -- the file is <i>downloaded</i> into the browser's 
default download location.</p>
<h3>Loading the Diagram</h3>
<p>The first step is to actually read the file data locally:</p>
<pre>// https://w3c.github.io/FileAPI/
// https://stackoverflow.com/questions/3582671/how-to-open-a-local-disk-file-with-javascript
// Loading the file after it has been loaded doesn't trigger this event again because it's
// hooked up to &quot;change&quot;, and the filename hasn't changed!
function readSingleFile(e) {
  var file = e.target.files[0];
  var reader = new FileReader();
  reader.onload = loadComplete;
  reader.readAsText(file);
  // Clears the last filename(s) so loading the same file will work again.
  document.getElementById(FILE_INPUT).value = &quot;&quot;;
}</pre>
<p>This function uses the WebAPI's <code>FileReader</code> class.&nbsp; The most 
interesting thing here is clearing the filename from the input element.&nbsp; As 
the comment points out, if we don't do this, we can't re-load the diagram if it 
has the same filename.&nbsp; Very annoying for testing.</p>
<p>When the load completes (I didn't implement any error checking / validation 
that the file is actually a diagram file):</p>
<pre>function loadComplete(e) {
  var contents = e.target.result;
  var endOfDiagramData = contents.indexOf(END_OF_DIAGRAM_TAG);
  var strDiagram = contents.substr(0, endOfDiagramData).substr(START_OF_DIAGRAM_TAG.length);
  var xmlDiagram = stringToXml(strDiagram);
  // Deserialize the diagram's surface XML element to restore grid spacing and grid translation.
  surface.deserialize(xmlDiagram);
  var svgData = contents.substr(endOfDiagramData + END_OF_DIAGRAM_TAG.length)
  replaceObjects(contents);
}</pre>
<p>Several things happen:</p>
<ul>
	<li>The data (as a string) is separated out into the diagram &quot;state&quot; 
	information -- currently just the surface state -- and the SVG data.</li>
<li>The surface state is restored.</li>
	<li>The &quot;objects&quot; element is replaced.</li>
</ul>
<p>The surface state is deserialized and restored:</p>
<pre>// Deserialize the xml fragment that contains the surface translation and grid dimensions on a file load.
deserialize(xml) {
  var obj = xmlToJson(xml);
  var attributes = obj.surface.attributes;
  // Note the attributes, because they were serialized by the DOM, are all lowercase.
  // OK to assume all ints?
  this.X = parseInt(attributes.x);
  this.Y = parseInt(attributes.y);
  this.gridCellW = parseInt(attributes.gridcellw);
  this.gridCellH = parseInt(attributes.gridcellh);
  this.cellW = parseInt(attributes.cellw);
  this.cellH = parseInt(attributes.cellh);
  var dx = this.X % this.gridCellW;
  var dy = this.Y % this.gridCellH;
  this.resizeGrid(this.gridCellW, this.gridCellH, this.cellW, this.cellH);
  this.svgElement.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
}</pre>
<p>The deserializer xmlToJson was found at the link in the comments.&nbsp; I 
made a minor tweak to the code described in that link:</p>
<pre>function stringToXml(xmlStr) {
  // <a href="https://stackoverflow.com/a/3054210/2276361">https://stackoverflow.com/a/3054210/2276361</a>
  return (new window.DOMParser()).parseFromString(xmlStr, &quot;text/xml&quot;);
}

// https://davidwalsh.name/convert-xml-json
function xmlToJson(xml) {
  var obj = {};

  if (xml.nodeType == 1) { // element
  // do attributes
    if (xml.attributes.length &gt; 0) {
      obj[&quot;attributes&quot;] = {};

      for (var j = 0; j &lt; xml.attributes.length; j++) {
        var attribute = xml.attributes.item(j);
        obj[&quot;attributes&quot;][attribute.nodeName] = attribute.nodeValue;
      }
   }
  } else if (xml.nodeType == 3) { // text
    obj = xml.nodeValue;
  }

  // do children
  if (xml.hasChildNodes()) {
    for(var i = 0; i &lt; xml.childNodes.length; i++) {
      var item = xml.childNodes.item(i);
      var nodeName = item.nodeName;

      if (typeof(obj[nodeName]) == &quot;undefined&quot;) {
        obj[nodeName] = xmlToJson(item);
      } else {
        if (typeof(obj[nodeName].push) == &quot;undefined&quot;) {
          var old = obj[nodeName];
          obj[nodeName] = [];
          obj[nodeName].push(old);
        }

      obj[nodeName].push(xmlToJson(item));
      }
    }
  }

  return obj;
};</pre>
<p>Next, the &quot;objects&quot; element is replaced.&nbsp; To do this, I wrapped the 
&quot;objects&quot; element in an group so that the child element of the wrapping group 
can be manipulated.</p>
<pre>&lt;!-- Also, we create an outer group so that on file load, we can remove
     the &quot;objectGroup&quot; and replace it with what got loaded. --&gt;
&lt;g id=&quot;objectGroup&quot;&gt;
  &lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;&lt;/g&gt;
&lt;/g&gt;</pre>
<p>The Javascript code:</p>
<pre>// Replace &quot;objects&quot; with the contents of what got loaded.
function replaceObjects(contents) {
  mouseController.destroyAllButSurface();
  var objectGroup = getElement(OBJECT_GROUP_ID);
  var objects = getElement(SVG_OBJECTS_ID);
  objectGroup.removeChild(objects);
  // <a href="https://stackoverflow.com/questions/38985998/insert-svg-string-element-into-an-existing-svg-tag">https://stackoverflow.com/questions/38985998/insert-svg-string-element-into-an-existing-svg-tag</a>
  objectGroup.innerHTML = contents;
  createShapeModels();
  // re-acquire the objects element after adding the contents.
  var objects = getElement(SVG_OBJECTS_ID);
  surface.svgObjects = objects;
}</pre>
<p>Several things happen in order to replace the &quot;objects&quot; element:</p>
<ul>
	<li>All objects except the &quot;surface&quot; currently on the surface are &quot;destroyed.&quot;&nbsp; This means 
	that:<ul>
		<li>Their events are unwired.</li>
		<li>They are detached from the mouse controller.</li>
	</ul>
	</li>
	<li>The child &quot;objects&quot; element is removed.</li>
	<li>The outer group's inner HTML is replaced with the SVG data that was 
	loaded from the file.</li>
	<li>Next, the backing shape classes (the &quot;models&quot; if you will) need to be 
	instantiated.&nbsp; This means:<ul>
		<li>Wiring up their events.</li>
		<li>Attaching them to the mouse controller.</li>
		<li>Fixing up their position so the object knows how they've been 
		translated.</li>
	</ul>
	</li>
	<li>Lastly:<ul>
		<li>The new &quot;objects&quot; element is acquired.</li>
		<li>The surface controller is told about the new &quot;objects&quot; element.</li>
	</ul>
</li>
</ul>
<p>Why are we destroying all SVG elements except the &quot;surface&quot; element?&nbsp; 
The surface element is effectively our placeholder element for the grid and 
handles the scrolling of the surface.&nbsp; We don't need to replace that 
element, so we ignore it:</p>
<pre>destroyAllButSurface() {
  Object.entries(this.controllers).map(([key, val]) =&gt; {
    if (!(val instanceof Surface)) {
      val.destroy();
    }
  });
}</pre>
<p>Creating the shape models is done with a lookup to map the <code>shapename</code> 
attribute to the function that instantiates the correct shape model:</p>
<pre>var elementNameShapeMap = {
  Rectangle: (mouseController, svgElement) =&gt; new Rectangle(mouseController, svgElement),
  Circle: (mouseController, svgElement) =&gt; new Circle(mouseController, svgElement),
  Diamond: (mouseController, svgElement) =&gt; new Diamond(mouseController, svgElement)
};
</pre>
<p>As an aside, where did the <code>shapename</code> attribute come from?&nbsp; 
This is created when the shape is dropped from a click or drag operation by the 
toolbox.&nbsp; In the SvgToolboxElement class:</p>
<pre>// set the shape name so we can map shape names to shape constructors when loading a diagram.
// https://stackoverflow.com/questions/1249531/how-to-get-a-javascript-objects-class
el.setAttributeNS(null, SHAPE_NAME_ATTR, this.constructor.name);
</pre>
<p>Also, in the same class, we add a class attribute that makes it easy to get 
all the SVG elements in the &quot;objects&quot; group:</p>
<pre>// Create a class common to all shapes so that, on file load, we can get them all and re-attach them
// to the mouse controller.
el.setAttributeNS(null, &quot;class&quot;, SHAPE_CLASS_NAME);</pre>
<p>Javascript for creating the shape models:</p>
<pre>// The difficult part -- creating the shape model based on the element's shapeName attribute to the shape controller class counterpart.
function createShapeModels() {
  var els = getElements(SHAPE_CLASS_NAME);

  for (let el of els) { // note usage &quot;of&quot; - ES6. note usage &quot;let&quot; : scope limited to block.
    let shapeName = el.getAttribute(SHAPE_NAME_ATTR);
    let creator = elementNameShapeMap[shapeName];
    let shape = creator(mouseController, el);
    // Annoyingly, we DO have to parse the translation to set the X and Y properties of the shape!
    let transform = el.getAttribute(&quot;transform&quot;);
    let transforms = parseTransform(transform);
    let translate = transforms[&quot;translate&quot;];
    // We assume integers?
    shape.X = parseInt(translate[0]);
    shape.Y = parseInt(translate[1]);
  }
}</pre>
<p>Annoyingly, we have to actually parse the transform because I don't add 
attributes to the SVG element for the model.&nbsp; This is done using some code 
I found on SO:</p>
<pre>// https://stackoverflow.com/questions/17824145/parse-svg-transform-attribute-with-javascript
function parseTransform(transform) {
  var transforms = {};
  for (var i in a = transform.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?)+\))+/g)) {
    var c = a[i].match(/[\w\.\-]+/g);
    transforms[c.shift()] = c;
  }

  return transforms;
}</pre>
<p>We now have a simple mechanism for saving and loading a diagram.&nbsp; When 
new shapes are added, only the <code>elementNameShapeMap</code> needs to be updated.</p>

<h2>Step 7: Lines and Anchor Points</h2>
<p>The last thing I want to create for this article is the ability to draw 
simple lines that can connect shapes.&nbsp; Easier said than done, as this means 
we will need some additional diagram state information so that we know what 
lines are attached to what shapes so that when the shape moves, the line is 
updated as well.&nbsp; I'm not even going to deal with
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">
arrows</a> yet!</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Conclusion</p>
<p>&nbsp;</p>

</body>

</html>